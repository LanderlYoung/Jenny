package com.young.util.jni.generator;

import com.young.util.jni.JNIHelper;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.Closeable;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.List;

/**
 * Author: LanderlYoung
 * Date:   2014-12-17
 * Time:   16:03
 * Life with passion. Code with creativity!
 */
public class CppCodeGenerator implements Runnable {
    private final Environment mEnv;
    private final TypeElement mClazz;
    private List<Element> mMethods;
    private final HandyHelper mHelper;

    //like com.example_package.SomeClass$InnerClass
    private String mClassName;
    //like com_example_1package_SomeClass_InnerClass
    private String mJNIClassName;
    //like com/example_package/SomeClass$InnerClass
    private String mNativeBinaryClassName;

    //header file name
    private String mHeaderName;
    //source file Name
    private String mSourceName;
    //target c/c++ file machine architecture
    private int mTargetArch;

    //DONE HandyHelper.toJNIType throwable
    //DONE Use NativeClass to mark generate, NativeMethod to add implements
    //DELETE different constant value for different arch
    //DONE fix get package name
    //DONE support for inner class
    //XXXX support for pure c code
    //DONE file output

    public CppCodeGenerator(Environment env,
            TypeElement clazz) {
        mEnv = env;
        mClazz = clazz;
        mMethods = new LinkedList<Element>();
        mHelper = new HandyHelper(env);
    }

    @Override
    public void run() {
        doGenerate();
    }

    public void doGenerate() {
        if (init() && !mMethods.isEmpty()) {
            genHeader();
            genSource();
        }
    }

    private boolean init() {
        if (!mClazz.getKind().equals(ElementKind.CLASS)) return false;

        mClassName = mHelper.getClassName(mClazz);
        mJNIClassName = JNIHelper.toJNIClassName(mClassName);
        mHeaderName = mJNIClassName + ".h";
        mSourceName = mJNIClassName + ".cpp";
        mNativeBinaryClassName = JNIHelper.getNativeBinaryClassName(mClassName);

        findArchitecture();

        findNativeMethods();

        return true;
    }

    private void findArchitecture() {
        NativeClass nc = mClazz.getAnnotation(NativeClass.class);
        //in normal ways, nc is not possible to be null
        if (nc != null) mTargetArch = nc.arch();
    }

    private void findNativeMethods() {
        List<? extends Element> elements = mClazz.getEnclosedElements();
        for (Element e : elements) {
            if (e.getKind().equals(ElementKind.METHOD)) {
                if (e.getModifiers().contains(Modifier.NATIVE)) {
                    mMethods.add(e);
                } else if (e.getAnnotation(NativeSource.class) != null) {
                    warn("Annotation @" + NativeSource.class.getSimpleName() + " should only be applied to NATIVE method!");
                }
            }
        }
    }

    private void log(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.NOTE,
                                   msg);
    }

    private void warn(String msg) {
        mEnv.messager.printMessage(Diagnostic.Kind.WARNING,
                                   msg);
    }

    public void genHeader() {
        PrintWriter w = null;
        try {
            //JavaFileObject fileObject = mEnv.filer.createSourceFile(mHeaderName);
            FileObject fileObject = mEnv.filer.createResource(StandardLocation.SOURCE_OUTPUT, "", mHeaderName);
            w = new PrintWriter(fileObject.openWriter());

            final String defineSwitch = "_Included_" + mJNIClassName;
            w.println("/* \n * JNI Header file generated by annotation JNI helper\n" +
                              " * written by landerlyoung@gmail.com\n */\n");
            w.println("/* C/C++ header file for class " + mClassName + " */");
            w.println("#ifndef " + defineSwitch);
            w.println("#define " + defineSwitch);
            w.println();
            w.println("#include <jni.h>");
            generateConstantsDefination(w);
            writeFunctions(w, false);

            writeNativeRegistrationFunc(w, false);

            w.println("\n#ifdef __cplusplus\n" +
                              "extern \"C\" {\n" +
                              "#endif");
            w.println("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);\n" +
                              "JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);");
            w.println("#ifdef __cplusplus\n" +
                              "}\n" +
                              "#endif");
            w.println("\n#endif");
        } catch (IOException e) {
            warn("generate header file " + mHeaderName + " failed!");
        } finally {
            closeSilently(w);
        }
    }

    private void writeNativeRegistrationFunc(PrintWriter w, boolean isSource) {
        w.println("/*\n * registe Native functions\n */");
        w.print("void register_");
        w.print(mJNIClassName);
        w.print("(JNIEnv *env)");
        if (!isSource) {
            w.println(";");
        } else {
            w.println(" {\n" +
                              "    jclass clazz = env->FindClass(FULL_CLASS_NAME);\n" +
                              "    env->RegisterNatives(clazz, gsNativeMethods,gsMethodCount);\n" +
                              "}\n");
        }
    }

    private void generateConstantsDefination(PrintWriter w) {
        for (Element e : mClazz.getEnclosedElements()) {
            if (e.getKind().equals(ElementKind.FIELD)) {
                VariableElement ve = (VariableElement) e;
                //if this field is a compile-time constant value it's
                //value will be returned, otherwise null will be returned.
                Object constValue = ve.getConstantValue();
                if (constValue != null) {
                    String defineName = mJNIClassName + "_" + ve.getSimpleName();
                    w.print("#undef  ");
                    w.println(defineName);
                    w.print("#define ");
                    w.print(defineName);
                    w.print(' ');
                    w.println(HandyHelper.getJNIHeaderConstantValue(constValue, mTargetArch));
                }
            }
        }
        w.println();
    }


    public void genSource() {
        PrintWriter w = null;
        try {
            FileObject fileObject = mEnv
                    .filer
                    .createResource(StandardLocation.SOURCE_OUTPUT
                            , "", mSourceName);
            w = new PrintWriter(fileObject.openWriter());

            w.println("#include \"" + mHeaderName + "\"\n");

            writeHelperMarcos(w);

            writeFunctions(w, true);

            //write JNI_OnLoad & JNI_OnUnload
            writeSourceTail(w);
        } catch (IOException e) {
            warn("generate source file " + mSourceName + " failed");
        } finally {
            closeSilently(w);
        }
    }

    private void writeHelperMarcos(PrintWriter w) {
        w.print("//java class name: ");
        w.println(mClassName);
        w.print("#define FULL_CLASS_NAME \"");
        w.print(mNativeBinaryClassName);
        w.println("\"");
        w.print("#define constants(cons) ");
        w.print(mJNIClassName);
        w.println("_ ## cons");
        w.println();
    }

    private static void closeSilently(Closeable c) {
        if (c == null) return;
        try {
            c.close();
        } catch (IOException e) {

        }
    }

    private void writeFunctions(PrintWriter w, boolean isSource) {
        for (Element m : mMethods) {
            ExecutableElement e = (ExecutableElement) m;

            //write comment
            w.print("/*\n" +
                            " * Class:     ");
            w.println(mJNIClassName);
            w.print(" * Method:    ");
            w.print(mClassName);
            w.print("::");
            w.println(m.getSimpleName().toString());
            w.print(" * Signature: ");
            w.println(mHelper.getMethodSignature(e));
            w.println(" */");

            w.print(mHelper.toJNIType(e.getReturnType()));
            w.print(" ");
            w.print(m.getSimpleName().toString());
            w.print("(JNIEnv *env");

            if (m.getModifiers().contains(Modifier.STATIC)) {
                w.print(", jclass clazz");
            } else {
                w.print(", jobject thiz");
            }

            List<? extends VariableElement> params = e.getParameters();
            for (VariableElement ve : params) {
                w.print(", ");
                w.print(mHelper.toJNIType(ve.asType()));
                w.print(' ');
                w.print(ve.getSimpleName().toString());
            }
            if (!isSource) {
                w.println(");\n");
            } else {
                w.write(") {\n");
                NativeSource a = m.getAnnotation(NativeSource.class);
                if (a != null) {
                    for (String s : a.value()) {
                        w.print("    ");
                        w.println(s);
                    }
                }
                w.println("}\n");
            }

        }
    }

    private void writeSourceTail(PrintWriter w) {
        w.println("static const JNINativeMethod gsNativeMethods[] = {");
        int methodLen = mMethods.size();
        for (int i = 0; i < methodLen; i++) {
            if (i == 0) {
                w.println("    {");
            } else {
                w.println("    }, {");
            }
            writeNativeMethodMapArray((ExecutableElement) mMethods.get(i), w);
            if (i == methodLen - 1) {
                w.println("    }");
            }
        }
        w.print("};\n" +
                        "static const int gsMethodCount =\n    sizeof(gsNativeMethods) / sizeof(JNINativeMethod); //");
        w.println(mMethods.size());
        w.println();

        writeNativeRegistrationFunc(w, true);
        //JNI_OnLoad
        w.print("JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n" +
                        "    JNIEnv* env;\n" +
                        "    if (vm->GetEnv(reinterpret_cast<void**>(&env),\n" +
                        "                JNI_VERSION_1_6) != JNI_OK) {\n" +
                        "        return -1;\n" +
                        "    }\n" +
                        "    register_");
        w.print(mJNIClassName);
        w.println("(env);");
        w.print("    return JNI_VERSION_1_6;\n" +
                        "}\n" +
                        "\n");

        //JNI_OnUnload
        w.println("JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved) {\n    \n}");
    }

    private void writeNativeMethodMapArray(ExecutableElement method,
            PrintWriter w) {
        final String methodName = method.getSimpleName().toString();
        w.print("        const_cast<char *>(");
        w.print('\"');
        w.print(methodName);
        w.println("\"),");

        w.print("        const_cast<char *>(");
        w.print('\"');
        w.print(mHelper.getBinaryMethodSignature(method));
        w.println("\"),");

        w.print("        reinterpret_cast<void *>(");
        w.print(methodName);
        w.println(')');
    }

}
